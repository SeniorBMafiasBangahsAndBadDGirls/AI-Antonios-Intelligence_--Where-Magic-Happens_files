<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI ANTONIOS INTELLIGENCE - Where Magic Happens</title>

  <!-- Tailwind CSS -->
  <link href="dist/output.css" rel="stylesheet">

  <!-- Video.js -->
  <link href="https://vjs.zencdn.net/8.10.0/video-js.css" rel="stylesheet" />
  <script src="https://vjs.zencdn.net/8.10.0/video.min.js"></script>

    <!-- Cropper.js (for client-side cropping) -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>

  <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-app.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-analytics.js";
        import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-auth.js";
        import { getFirestore, setLogLevel, doc, setDoc, onSnapshot, collection, addDoc, serverTimestamp, query, orderBy } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-firestore.js";
        import { getStorage } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-storage.js";

    const firebaseConfig = {
      apiKey: "AIzaSyBC3jRqiVMdFHONBZwtmpHFj6q-ZF4pKB8",
      authDomain: "ai-antonios-intelligence.firebaseapp.com",
      projectId: "ai-antonios-intelligence",
      storageBucket: "ai-antonios-intelligence.firebasestorage.app",
      messagingSenderId: "196721251681",
      appId: "1:196721251681:web:ba15bc86d11619fb73e120",
      measurementId: "G-50YW86EWCS"
    };

    // Initialize and expose globally
    window.app = initializeApp(firebaseConfig);
    window.analytics = getAnalytics(window.app);
    window.auth = getAuth(window.app);
    window.db = getFirestore(window.app);
    window.storage = getStorage(window.app);

    setLogLevel('debug');

        window.firebaseConfig = firebaseConfig;
        window.initializeApp = initializeApp;
        window.getAuth = getAuth;
        window.getFirestore = getFirestore;
        window.onAuthStateChanged = onAuthStateChanged;
        window.setLogLevel = setLogLevel;

        // Expose commonly used Firestore helpers so inline scripts can use them
        window.doc = doc;
        window.setDoc = setDoc;
        window.onSnapshot = onSnapshot;
        window.collection = collection;
        window.addDoc = addDoc;
        window.serverTimestamp = serverTimestamp;
        window.query = query;
        window.orderBy = orderBy;
  </script>
    <script>
                // Listen for user's beat purchases
                const userPurchaseDoc = doc(db, 'artifacts', appId, 'users', userId, 'purchases', 'beat_purchase');
                onSnapshot(userPurchaseDoc, (docSnap) => {
                    if (docSnap.exists()) {
                        console.log("Beat purchased. Studio unlocked.");
                    } else {
                        console.log("Beat not purchased. Studio locked.");
                    }
                }, (error) => {
                    console.error("Error fetching purchase data:", error);
                });

                // Listen for chat messages from the public collection
                const chatCollection = collection(db, 'artifacts', appId, 'public', 'data', 'conversations');
                const chatQuery = query(chatCollection, orderBy('timestamp'));
                
                onSnapshot(chatQuery, (snapshot) => {
                    messagesDisplay.innerHTML = '';
                    snapshot.forEach(doc => {
                        const message = doc.data();
                        const messageContainer = document.createElement('div');
                        messageContainer.classList.add('chat-message');

                        const messageText = document.createElement('span');
                        messageText.textContent = message.text;
                        messageContainer.appendChild(messageText);

                        if (message.sender === 'user') {
                            messageContainer.classList.add('user-message');
                        } else {
                            messageContainer.classList.add('ai-message');
                            const ttsButton = document.createElement('button');
                            ttsButton.innerHTML = 'ðŸ”Š'; // Speaker icon
                            ttsButton.classList.add('tts-button', 'ml-2', 'p-1', 'text-sm', 'rounded-full', 'bg-purple-600', 'hover:bg-purple-700', 'flex-shrink-0');
                            ttsButton.style.width = '2rem';
                            ttsButton.style.height = '2rem';
                            ttsButton.dataset.text = message.text;
                            messageContainer.appendChild(ttsButton);
                        }
                        messagesDisplay.appendChild(messageContainer);
                    });
                    messagesDisplay.scrollTop = messagesDisplay.scrollHeight;
                }, (error) => {
                    console.error("Error fetching chat messages:", error);
                });

                // Listen for BadDGirl status
                const baddgirlStatusDoc = doc(db, 'artifacts', appId, 'public', 'data', 'app_status', 'baddgirl');
                onSnapshot(baddgirlStatusDoc, (docSnap) => {
                    if (docSnap.exists() && docSnap.data().approved) {
                        baddgirlStatus.textContent = 'Approved!';
                        baddgirlStatus.classList.remove('status-waiting');
                        baddgirlStatus.classList.add('status-approved');
                        approveBaddgirlBtn.disabled = true;
                        approveBaddgirlBtn.textContent = 'Approved';
                        approveBaddgirlBtn.classList.remove('bg-lime-500', 'hover:bg-lime-600');
                        approveBaddgirlBtn.classList.add('bg-gray-500', 'cursor-not-allowed');
                    } else {
                        baddgirlStatus.textContent = 'Waiting to Enter...';
                        baddgirlStatus.classList.remove('status-approved');
                        baddgirlStatus.classList.add('status-waiting');
                        approveBaddgirlBtn.disabled = false;
                        approveBaddgirlBtn.textContent = 'Approve BadDGirl';
                        approveBaddgirlBtn.classList.add('bg-lime-500', 'hover:bg-lime-600');
                        approveBaddgirlBtn.classList.remove('bg-gray-500', 'cursor-not-allowed');
                    }
                }, (error) => {
                    console.error("Error fetching BadDGirl status:", error);
                });
            }
            
            // Insert an Enable Camera button to trigger camera start via user gesture
            const promptContainer = document.getElementById('prompt-message');
            const enableCamBtn = document.createElement('button');
            enableCamBtn.id = 'enable-camera-btn';
            enableCamBtn.className = 'mt-4 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg';
            enableCamBtn.textContent = 'Enable Camera';
            enableCamBtn.setAttribute('aria-label', 'Enable camera and microphone');
            promptContainer.parentNode.insertBefore(enableCamBtn, promptContainer.nextSibling);

            // Call startCamera only on user gesture (click) to improve autoplay success and permissions
            enableCamBtn.addEventListener('click', async () => {
                enableCamBtn.disabled = true;
                enableCamBtn.textContent = 'Connecting...';
                await startCamera();
                enableCamBtn.style.display = 'none';
            });

            // Camera retry button wiring
            const cameraRetryBtn = document.getElementById('camera-retry-btn');
            cameraRetryBtn.addEventListener('click', async () => {
                cameraRetryBtn.disabled = true;
                cameraRetryBtn.textContent = 'Retrying...';
                await startCamera();
            });

            // Stop camera stream when the page is unloaded to release the device
            window.addEventListener('beforeunload', () => {
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    console.log("Camera stream stopped on page unload.");
                }
            });

            // Handle beat purchase
            purchaseBeatBtn.addEventListener('click', async () => {
                if (!userId) {
                    showMessage("Authentication not ready. Please wait a moment and try again.");
                    return;
                }
                try {
                    const userPurchaseDoc = doc(db, 'artifacts', appId, 'users', userId, 'purchases', 'beat_purchase');
                    await setDoc(userPurchaseDoc, {
                        beatId: 'raydiant_beat',
                        purchaseDate: new Date().toISOString()
                    });
                    showMessage("Purchase successful! The studio is now unlocked.");
                    console.log("Beat purchase document created.");
                } catch (e) {
                    console.error("Error purchasing beat:", e);
                    showMessage("An error occurred during the purchase. Please try again.");
                }
            });
            
            async function callGeminiApi(prompt) {
                const chatCollection = collection(db, 'artifacts', appId, 'public', 'data', 'conversations');
                try {
                    const payload = {
                        contents: [{ parts: [{ text: prompt }] }],
                    };

                    const apiKey = "YOUR_ACTUAL_GEMINI_API_KEY_HERE"; // â† Fix this
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

                    let attempts = 0;
                    const maxAttempts = 5;
                    const baseDelay = 1000;

                    const fetchWithRetry = async () => {
                        try {
                            const response = await fetch(apiUrl, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(payload)
                            });

                            if (!response.ok) {
                                if (response.status === 429 && attempts < maxAttempts) {
                                    const delay = baseDelay * (2 ** attempts);
                                    attempts++;
                                    console.log(`Rate limit exceeded. Retrying in ${delay}ms...`);
                                    await new Promise(res => setTimeout(res, delay));
                                    return fetchWithRetry();
                                } else {
                                    const errorBody = await response.text();
                                    throw new Error(`API response error: ${response.status} ${response.statusText}. Body: ${errorBody}`);
                                }
                            }

                            const result = await response.json();
                            const aiResponseText = result?.candidates?.[0]?.content?.parts?.[0]?.text || "No response.";
                            
                            await addDoc(chatCollection, {
                                sender: 'ai',
                                text: aiResponseText,
                                timestamp: serverTimestamp()
                            });

                        } catch (error) {
                            console.error("Failed to get AI response:", error);
                            await addDoc(chatCollection, {
                                sender: 'ai',
                                text: "My apologies, I'm having a little trouble connecting to the network right now. Please try again in a moment.",
                                timestamp: serverTimestamp()
                            });
                        }
                    };
                    
                    await fetchWithRetry();

                } catch (error) {
                    console.error("Error during API processing:", error);
                }
            }
            
            // --- Text-to-Speech (TTS) Feature ---
            
            function base64ToArrayBuffer(base64) {
                const binaryString = window.atob(base64);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes.buffer;
            }

            function writeString(view, offset, string) {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            }

            function pcmToWav(pcmData, numChannels, sampleRate) {
                const blockAlign = numChannels * 2; // 16-bit samples
                const byteRate = sampleRate * blockAlign;
                const dataSize = pcmData.length * 2;
                const buffer = new ArrayBuffer(44 + dataSize);
                const view = new DataView(buffer);
                writeString(view, 0, 'RIFF');
                view.setUint16(32, blockAlign, true);
                view.setUint16(34, 16, true); // 16-bits per sample
                writeString(view, 36, 'data');
                view.setUint32(40, dataSize, true);
                for (let i = 0; i < pcmData.length; i++) {
                    view.setInt16(44 + i * 2, pcmData[i], true);
                }
                return new Blob([view], { type: 'audio/wav' });
            }
            
            async function playTTSSound(text, buttonElement) {
                buttonElement.disabled = true;
                buttonElement.textContent = '...';

                try {
                    const payload = {
                        contents: [{ parts: [{ text: `Say with a cool, encouraging tone: ${text}` }] }],
                        generationConfig: { responseModalities: ["AUDIO"] },
                        model: "gemini-2.5-flash-preview-tts"
                    };
                    const apiKey = "";
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;
                    
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    
                    if (!response.ok) {
                        const errorBody = await response.text();
                        console.error("TTS API Error Body:", errorBody);
                        throw new Error(`TTS API Error: ${response.status} ${response.statusText}`);
                    }

                    const result = await response.json();
                    const part = result?.candidates?.[0]?.content?.parts?.[0];
                    const audioData = part?.inlineData?.data;
                    const mimeType = part?.inlineData?.mimeType;

                    if (audioData && mimeType && mimeType.startsWith("audio/")) {
                        const sampleRate = parseInt(mimeType.match(/rate=(\d+)/)[1], 10);
                        const pcmData = base64ToArrayBuffer(audioData);
                        const pcm16 = new Int16Array(pcmData);
                        const wavBlob = pcmToWav(pcm16, 1, sampleRate);
                        const audioUrl = URL.createObjectURL(wavBlob);
                        const audio = new Audio(audioUrl);
                        audio.play();
                        audio.onended = () => {
                            buttonElement.disabled = false;
                            buttonElement.innerHTML = 'ðŸ”Š';
                        };
                    } else {
                        throw new Error("Invalid audio data in response.");
                    }

                } catch (error) {
                    console.error("Error generating TTS:", error);
                    showMessage("Sorry, couldn't generate the audio at this moment.");
                    buttonElement.disabled = false;
                    buttonElement.innerHTML = 'ðŸ”Š';
                }
            }

            messagesDisplay.addEventListener('click', (e) => {
                const ttsButton = e.target.closest('.tts-button');
                if (ttsButton) {
                    const textToSpeak = ttsButton.dataset.text;
                    playTTSSound(textToSpeak, ttsButton);
                }
            });

            // Handle chat form submission
            chatForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const userMessage = chatInput.value.trim();
                if (!userMessage) return;

                const chatCollection = collection(db, 'artifacts', appId, 'public', 'data', 'conversations');
                await addDoc(chatCollection, {
                    sender: 'user',
                    text: userMessage,
                    timestamp: serverTimestamp()
                });
                chatInput.value = '';

                const prompt = `You are Ray D Antonio's personal AI twin, named 'Gemini'. Your purpose is to act as a rhyme coach and editor. When the user provides a rhyme, you will correct any grammatical errors or awkward phrasing, and then provide a brief, supportive explanation for your changes. Always respond in a conversational and encouraging tone. The user's rhyme is: "${userMessage}"`;
                await callGeminiApi(prompt);
            });
            
            // Handle "Generate Rhyme" button click
            generateRhymeBtn.addEventListener('click', async () => {
                const zodiacSign = "Pisces Ghost"; // Hardcoded for now
                const prompt = `You are Ray D Antonio's personal AI twin, named 'Gemini'. Your purpose is to be a creative muse. Generate a short, inspiring, and creative rhyme for a user whose zodiac sign is ${zodiacSign}. The rhyme should be about creativity, music, and their astrological sign. Keep it to 4-6 lines.`;
                
                generateRhymeBtn.disabled = true;
                generateRhymeBtn.textContent = 'Generating...';
                
                await callGeminiApi(prompt);

                generateRhymeBtn.disabled = false;
                generateRhymeBtn.innerHTML = 'âœ¨ Generate Rhyme';
            });

            // --- Avatar Image Generation Feature ---
            generateAvatarBtn.addEventListener('click', async () => {
                generateAvatarBtn.disabled = true;
                generateAvatarBtn.textContent = 'Generating...';

                const prompt = "A mystical, artistic avatar for a musician named 'Pisces Ghost'. A ghostly figure with elements of the Pisces zodiac sign (like two fish or water themes). Modern hip-hop, street art style. Ethereal, cool colors like purple, blue, and silver.";

                try {
                    const payload = { instances: [{ prompt: prompt }], parameters: { "sampleCount": 1 } };
                    const apiKey = ""; 
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${apiKey}`;
                    
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        throw new Error(`Image API Error: ${response.statusText}`);
                    }
                    
                    const result = await response.json();
                    if (result.predictions && result.predictions.length > 0 && result.predictions[0].bytesBase64Encoded) {
                        const imageUrl = `data:image/png;base64,${result.predictions[0].bytesBase64Encoded}`;
                        userAvatar.src = imageUrl;
                    } else {
                        throw new Error("Invalid image data in response.");
                    }

                } catch(error) {
                    console.error("Error generating avatar:", error);
                    showMessage("Sorry, I couldn't create a new look right now. Please try again later.");
                } finally {
                    generateAvatarBtn.disabled = false;
                    generateAvatarBtn.innerHTML = 'âœ¨ Generate New Look';
                }
            });


       // Handle beat upload
document.getElementById('beat-upload').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
        const url = URL.createObjectURL(file);
        const ext = file.name.split('.').pop().toLowerCase();

        let srcType = '';
        if (ext === 'mp3' || ext === 'wav') {
            srcType = 'audio/' + ext;
        } else if (ext === 'mp4') {
            srcType = 'video/mp4';
        } else {
            showMessage('Unsupported file type. Please upload an MP3, WAV, or MP4 file.');
            return;
        }

        customPlayer.reset();
        customPlayer.src({ type: srcType, src: url });
        customPlayer.load();
        beatNameDisplay.textContent = `Now Playing: ${file.name}`;
        console.log(`File uploaded and loaded: ${file.name}`);
    }
});
// ...existing code...       // ** Camera and BadDGirl approval functionality **
            async function startCamera() {
                const promptMessage = document.getElementById('prompt-message');
                const statusText = document.getElementById('camera-status-text');
                const retryBtn = document.getElementById('camera-retry-btn');

                promptMessage.textContent = "Attempting to connect to camera...";
                if (statusText) statusText.textContent = 'Camera status: connecting...';
                if (retryBtn) retryBtn.classList.add('hidden');

                // Stop any existing stream before starting a new one
                if (localStream) {
                    try { localStream.getTracks().forEach(track => track.stop()); } catch (e) { console.warn('Error stopping previous stream', e); }
                    localStream = null;
                    console.log("Stopped existing camera stream.");
                }

                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { width: { ideal: 1280 }, height: { ideal: 720 } },
                        audio: false
                    });

                    localStream = stream;
                    if (localVideo) {
                        localVideo.srcObject = stream;
                        try { await localVideo.play(); } catch (playErr) { console.debug('Autoplay prevented, user gesture required to start video playback', playErr); }
                    }

                    promptMessage.textContent = "Camera connected successfully!";
                    if (statusText) statusText.textContent = 'Camera status: connected';
                    if (retryBtn) { retryBtn.classList.add('hidden'); }
                    console.log("Camera stream started.");
                } catch (err) {
                    console.error("Error accessing the camera:", err);
                    let errorMessage = "Could not access your camera. Please check your browser permissions.";
                    if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                        errorMessage = "Camera access was denied. Please allow camera access in your browser settings.";
                        promptMessage.textContent = "Camera access denied. Please check your browser settings.";
                    } else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') {
                        errorMessage = "No camera was found on your device.";
                        promptMessage.textContent = "No camera detected.";
                    } else if (err.name === 'NotReadableError' || (err.message && err.message.toLowerCase().includes('device in use'))) {
                        errorMessage = "Your camera may be in use by another application or browser tab. Please close other programs using the camera and try again.";
                        promptMessage.textContent = "Camera in use by another app.";
                    } else {
                        promptMessage.textContent = "Camera error. Please check your settings.";
                    }

                    if (statusText) statusText.textContent = `Camera status: error - ${errorMessage}`;
                    if (retryBtn) {
                        retryBtn.classList.remove('hidden');
                        retryBtn.disabled = false;
                        retryBtn.textContent = 'Retry Camera';
                    }
                    showMessage(errorMessage);
                }
            }
            
            approveBaddgirlBtn.addEventListener('click', async () => {
                if (!userId) {
                    showMessage("Authentication not ready. Please wait a moment and try again.");
                    return;
                }
                try {
                    const baddgirlStatusDoc = doc(db, 'artifacts', appId, 'public', 'data', 'app_status', 'baddgirl');
                    await setDoc(baddgirlStatusDoc, { approved: true, approvedBy: userId, timestamp: serverTimestamp() }, { merge: true });
                    showMessage("You have approved BadDGirl's camera stream!");
                } catch (e) {
                    console.error("Error approving BadDGirl's camera:", e);
                    showMessage("An error occurred. Could not approve camera.");
                }
            });
            
            // ** Recording functionality **
            let audioStream = null; // separate audio stream so it doesn't interfere with camera

            recordBtn.addEventListener('click', async () => {
                try {
                    // Request only audio
                    audioStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                    mediaRecorder = new MediaRecorder(audioStream);
                    audioChunks = [];

                    mediaRecorder.ondataavailable = event => {
                        audioChunks.push(event.data);
                    };

                    mediaRecorder.onstop = () => {
                        audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        const audioUrl = URL.createObjectURL(audioBlob);

                        recordingPlayer.src = audioUrl;
                        recordingPlayback.classList.remove('hidden');
                        saveRecordingBtn.href = audioUrl;

                        // Stop just the audio tracks for this recording stream
                        if (audioStream) {
                            try { audioStream.getTracks().forEach(track => track.stop()); } catch(e){ console.warn('Failed to stop audioStream tracks', e); }
                            audioStream = null;
                        }
                    };

                    mediaRecorder.start();
                    recordBtn.textContent = 'Recording...';
                    recordBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
                    recordBtn.classList.add('bg-gray-500', 'cursor-not-allowed');
                    recordBtn.disabled = true;
                    stopRecordBtn.disabled = false;
                    recordingPlayback.classList.add('hidden'); // Hide playback until recording is stopped
                    console.log("Recording started.");
                } catch (e) {
                    console.error("Error starting recording:", e);
                    showMessage("Could not access your microphone. Please check your browser permissions.");
                }
            });

            stopRecordBtn.addEventListener('click', () => {
                if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                    mediaRecorder.stop();
                    recordBtn.textContent = 'Record';
                    recordBtn.classList.remove('bg-gray-500', 'cursor-not-allowed');
                    recordBtn.classList.add('bg-red-600', 'hover:bg-red-700');
                    recordBtn.disabled = false;
                    stopRecordBtn.disabled = true;
                    console.log("Recording stopped.");
                }
            });


            // Placeholder for MP3/WAV/Stems purchase
            document.getElementById('purchase-mp3-wav').addEventListener('click', () => {
                showMessage("Master MP3/WAV/Stems purchased successfully! Awaiting your next move.");
            });
            
            // Placeholder for MP4 purchase and subscription
            document.getElementById('purchase-mp4').addEventListener('click', () => {
                showMessage("MP4 purchased! Welcome to the AI ANTONIOS INTELIGENCE SeniorBMafias Bangahs&BadDGirls enterprize.");
            });
        });
</script>
    <!-- Load main app module -->
    <script type="module" src="/src/main-module.js"></script>
</body>
</html>